1) Spring как семейство проектов. SpringFramework - состав и назначение. 
   - Spring как семейство проектов состоит из различных модулей и фреймворков, которые предоставляют поддержку для разработки приложений на Java. Основной и наиболее известный модуль - Spring Framework.
   - Spring Framework является комплексным решением для разработки приложений на Java. Он предоставляет множество функциональных возможностей, таких как управление жизненным циклом объектов, внедрение зависимостей (Dependency Injection), аспектно-ориентированное программирование (Aspect-Oriented Programming), транзакционность и многое другое.
   - Основные модули Spring Framework включают:
     - Spring Core: основные функциональности, такие как внедрение зависимостей и управление жизненным циклом бинов.
     - Spring MVC: фреймворк для разработки веб-приложений, предоставляющий поддержку для реализации шаблона проектирования Model-View-Controller (MVC).
     - Spring Data: модуль для работы с различными источниками данных, такими как базы данных, NoSQL хранилища и т.д.
     - Spring Security: модуль, предоставляющий механизмы аутентификации и авторизации для приложений.
     - Кроме того, Spring Framework включает множество других модулей и расширений, которые обеспечивают поддержку различных аспектов разработки приложений, таких как интеграция с базами данных, работа с веб-сервисами, обработка сообщений и многое другое.
2) Что нового в Spring Framework 5.0
   - Поддержка Java 8 и выше: Spring Framework 5.0 внедрил полную поддержку Java 8 и включил в себя новые возможности языка, такие как лямбда-выражения и функциональные интерфейсы.
   - Реактивное программирование: введение Reactive Streams API и поддержка реактивного программирования стало одной из ключевых особенностей Spring Framework 5.0. Теперь разработчики могут создавать реактивные приложения, используя новые аннотации, классы и подходы.
   - Поддержка реактивного веб-стека: Spring WebFlux, новый модуль в Spring Framework 5.0, предоставляет возможность разработки реактивных веб-приложений. Он основан на реактивном программировании и поддерживает неблокирующую обработку запросов.
   - Улучшенная поддержка Kotlin: Spring Framework 5.0 улучшил интеграцию с языком программирования Kotlin, включая расширения для удобной работы с Kotlin-кодом.
3) Конфигурация Spring. WebMvcConfigurer. Аннотации:@ Controller, @Repository, @Service.
   - Конфигурация Spring осуществляется с помощью различных подходов, включая XML-конфигурацию и аннотации. В Spring Framework есть несколько важных аннотаций, которые используются для конфигурации различных компонентов:
     - @Controller: аннотация, которая используется для пометки класса как контроллера веб-приложения. Класс, помеченный этой аннотацией, может обрабатывать HTTP-запросы и возвращать соответствующие ответы.
     - @Repository: аннотация, которая используется для пометки класса как репозитория данных. Репозиттории Spring Data используют эту аннотацию для управления доступом к данным, таким как базы данных.
     - @Service: аннотация, которая используется для пометки класса как сервисного компонента. Классы, помеченные этой аннотацией, содержат бизнес-логику и обеспечивают различные сервисные функции.
4) Адресация в Контроллере. @RequestMapping, @GetMapping и др. 
5) Понятие Inversion of Control-контейнер (IOС) и Dependency Injection (DI)
      - Inversion of Control (IoC) - это принцип, согласно которому контроль над созданием и управлением зависимостями объектов передается внешнему компоненту, известному как контейнер IoC. Вместо того чтобы объекты создавали свои собственные зависимости, они получают их от контейнера IoC. Это приводит к уменьшению связанности компонентов и повышению их переиспользуемости и тестируемости.
      - Dependency Injection (DI) - это конкретная реализация принципа IoC, которая заключается в том, что зависимости объекта передаются в него извне, обычно через конструкторы, сеттеры или другие методы. Это позволяет легко заменять зависимости и облегчает тестирование, поскольку зависимости могут быть легко заменены на фиктивные (mock) объекты в тестовых средах.  
   - В контексте Spring Framework контейнер IoC называется ApplicationContext, который управляет созданием и жизненным циклом бинов (объектов, управляемых Spring). Это позволяет разработчикам определить бины и их зависимости в конфигурационных файлах или аннотациях, а Spring самостоятельно создаст и свяжет их во время выполнения приложения.
6) Spring Expression Language (SpEL): особенности и область использования.
   - Spring Expression Language (SpEL) - это язык выражений, который предоставляет мощные возможности для оценки и манипулирования объектами в Spring Framework. SpEL позволяет использовать выражения в различных контекстах, таких как конфигурационные файлы, аннотации, XML-описания и другие.
   - Особенности:
     - Вычисление значений: SpEL позволяет вычислять значения выражений, которые могут быть использованы для установки значений свойств объектов или аргументов методов.
     - Доступ к свойствам объектов: SpEL позволяет получать доступ к свойствам объектов и вызывать их методы, используя синтаксис, подобный языку программирования.
     - Операции и функции: SpEL предоставляет широкий спектр операций и функций, таких как арифметические операции, операции сравнения, логические операции, операции со строками и другие.
     - Коллекции и индексы: SpEL поддерживает работу с коллекциями, включая списки, множества и карты, а также доступ к элементам коллекций по индексу или ключу.
     - Условные выражения: SpEL поддерживает условные выражения, такие как if-else, ternary-операторы и операторы выбора.
7) Spring Framework Validation. Интерфейс Validator. Правила валидации и ограничения.
   - Spring Framework Validation - это механизм валидации, предоставляемый Spring Framework, который позволяет проверять и обрабатывать входные данные при выполнении операций в приложении. Валидация помогает обеспечить корректность и целостность данных, а также уменьшить возможность ошибок.
   - Основные компоненты валидации в Spring Framework:
     - Интерфейс Validator: Интерфейс org.springframework.validation.Validator определяет методы, которые должны быть реализованы для проведения валидации объекта. Метод supports(Class<?> clazz) определяет, поддерживается ли валидация для данного класса объекта, а метод validate(Object target, Errors errors) выполняет фактическую валидацию объекта и добавляет ошибки (если они есть) в объект типа Errors.
     - Правила валидации и ограничения: Spring Framework предоставляет различные аннотации, которые могут быть использованы для определения правил валидации и ограничений для полей объектов. Некоторые из наиболее распространенных аннотаций включают @NotNull, @NotEmpty, @Min, @Max, @Pattern и другие. Эти аннотации могут применяться к полям объектов или аргументам методов для определения требований к значениям.
8) Понятие ORM. Архитектура ЈРA: EntityManager, Persistence …
   - Понятие ORM (Object-Relational Mapping) - это подход к взаимодействию с базами данных, который позволяет разработчикам использовать объектно-ориентированный подход при работе с данными, хранящимися в реляционных базах данных. ORM предоставляет абстракцию над базой данных, позволяя работать с данными в терминах объектов и классов, вместо работы с низкоуровневыми SQL-запросами.
   - Архитектура JPA (Java Persistence API):
     - EntityManager: EntityManager является центральным интерфейсом JPA и предоставляет методы для выполнения операций сущностей, таких как поиск, сохранение, обновление и удаление. Он представляет контекст персистентности и отвечает за отслеживание изменений, синхронизацию с базой данных и управление жизненным циклом сущностей.
     - Persistence: Persistence - утилитарный класс JPA, который используется для создания и настройки EntityManagerFactory. EntityManagerFactory представляет собой фабрику EntityManager и создает экземпляры EntityManager для работы с базой данных.
     - Entity: Entity представляет объектно-ориентированное представление данных, хранимых в базе данных. Он обычно соответствует таблице в базе данных и содержит аннотации для отображения полей класса на столбцы таблицы.
9)  Требования в Entity. Жизненный цикл Entity. Типы связей. Spring Data Annotations.
    - Требования:
      - Сущность (Entity) должна быть классом, который соответствует таблице в базе данных или другому хранилищу данных.
      - Класс сущности должен иметь пустой конструктор, чтобы ORM-фреймворк мог создавать экземпляры сущностей при чтении данных из базы данных.
      - Каждая сущность должна иметь уникальный идентификатор, обычно представленный полем с аннотацией @Id. Идентификатор может быть сгенерирован автоматически (например, с помощью аннотации @GeneratedValue) или устанавливаться вручную.
      - Поля сущности должны соответствовать столбцам таблицы базы данных. ORM-фреймворк использует аннотации, такие как @Column, для указания соответствия между полями класса и столбцами таблицы.
    - ЖЦ:
      - New (Новая): Сущность создана, но еще не связана с контекстом персистентности или базой данных.
      - Managed (Управляемая): Сущность связана с контекстом персистентности и управляется ORM-фреймворком. Изменения, внесенные в сущность, будут отслеживаться и автоматически синхронизироваться с базой данных.
      - Removed (Удаленная): Сущность отмечена для удаления из базы данных. При синхронизации с базой данных она будет удалена.
      - Detached (Отсоединенная): Сущность больше не связана с контекстом персистентности. Изменения, внесенные в отсоединенную сущность, не будут автоматически синхронизироваться с базой данных.
    - Типы связей:
      - OneToMany
      - OneToOne
      - ManyToMany
      - ManyToOne
10) Spring Data Annotations.
    - Spring Data Annotations - это набор аннотаций, предоставляемых Spring Data, которые упрощают разработку и интеграцию с различными базами данных. Некоторые из наиболее распространенных аннотаций Spring Data включают:
      - @Entity: аннотация, которая помечает класс как сущность базы данных. Используется в связке с JPA (Java Persistence API) для создания отображения между классом и таблицей в базе данных.
      - @Table: аннотация, которая позволяет указать имя таблицы, связанной с сущностью. Может использоваться для определения дополнительных атрибутов таблицы, таких как название схемы или индексы.
      - @Column: аннотация, которая используется для указания отображения поля класса на столбец таблицы базы данных. Позволяет настроить различные атрибуты столбца, такие как имя, тип данных, ограничения и другие.
      - @Id: аннотация, которая указывает поле класса как первичный ключ таблицы.
      - @GeneratedValue: аннотация, которая указывает, что значение первичного ключа должно быть автоматически генерируемым. Может использоваться с различными стратегиями генерации, такими как автоинкремент, последовательности и другие.
      - @Repository: аннотация, которая помечает класс как репозиторий, предоставляющий доступ к базе данных. Часто используется в связке с другими Spring Data аннотациями, такими как @Query для определения пользовательских запросов.
      - @Service: аннотация, которая помечает класс как сервисный компонент. Используется для обозначения класса, который содержит бизнес-логику приложения.
      - @Autowired: аннотация, которая осуществляет автоматическую инъекцию зависимостей в Spring-компоненты. Используется для внедрения зависимостей в поля, сеттеры или конструкторы классов.
      - @Transactional: аннотация, которая указывает, что метод должен выполняться в рамках транзакции. Обычно используется для методов доступа к базе данных, чтобы обеспечить атомарность и консистентность операций.
11)  ЈРА механизм обратных вызовов (@Pre... @Post...). Запросы 
    - JPA (Java Persistence API) - это стандартная спецификация Java для работы с реляционными базами данных. В JPA существуют механизмы обратных вызовов, которые позволяют приложению реагировать на различные события жизненного цикла сущностей, такие как создание, обновление или удаление.
    - Некоторые из аннотаций JPA, используемых для определения механизмов обратных вызовов, включают:
      - @PrePersist: аннотация, которая указывает метод, который должен быть вызван перед сохранением новой сущности в базу данных.
      - @PostPersist: аннотация, которая указывает метод, который должен быть вызван после сохранения новой сущности в базе данных.
      - @PreUpdate: аннотация, которая указывает метод, который должен быть вызван перед обновлением сущности в базе данных.
      - @PostUpdate: аннотация, которая указывает метод, который должен быть вызван после обновления сущности в базе данных.
      - @PreRemove: аннотация, которая указывает метод, который должен быть вызван перед удалением сущности из базы данных.
12)  Паттерн Service, Repository, Controller.  
    - Сервис (Service): Сервисный компонент является слоем бизнес-логики приложения. Он содержит методы, которые реализуют специфическую бизнес-логику и взаимодействуют с репозиторием для доступа к данным. Сервисы могут выполнять операции, такие как валидация данных, обработка бизнес-правил и координация различных репозиториев.
    - Репозиторий (Repository): Репозиторий предоставляет абстракцию для доступа к данным. Он обеспечивает методы для поиска, сохранения, обновления и удаления данных в базе данных или другом источнике данных. Репозиторий скрывает детали взаимодействия с конкретным источником данных и предоставляет единый интерфейс для работы с данными.
    - Контроллер (Controller): Контроллер обрабатывает входящие запросы от клиента и управляет потоком выполнения в приложении. Он принимает запросы, вызывает соответствующие методы сервисов для выполнения бизнес-логики и возвращает ответы клиенту. Контроллер обычно обрабатывает валидацию входных данных, управление сеансами и формирование модели данных для передачи на представление.
13) В чём разница между @Controller и @RestController
    - @Controller: Аннотация @Controller используется в Spring Framework для обозначения класса как компонента контроллера, который обрабатывает HTTP-запросы и возвращает представления (views). Методы контроллера могут использовать аннотации, такие как @RequestMapping, для маппинга URL-путей и определения обработчиков для различных HTTP-методов.
    - @RestController: Аннотация @RestController является специальным видом @Controller, предназначенным для создания RESTful веб-сервисов. Класс, помеченный этой аннотацией, автоматически добавляет аннотации @Controller и @ResponseBody ко всем методам. Результаты методов возвращаются в виде данных (например, JSON или XML), а не представлений.
14) Понятие REST. Требования к RESP архитектуре.
    - Понятие REST (Representational State Transfer) - это архитектурный стиль для разработки распределенных систем, основанный на принципах, описанных в докладе Роя Филдинга (Roy Fielding) в 2000 году. REST определяет набор принципов и ограничений, которые позволяют создавать масштабируемые и гибкие веб-сервисы.
    - Требования к архитектуре REST:
      - Клиент-серверная архитектура: Система разделена на клиентов и серверы, которые взаимодействуют посредством стандартизированных интерфейсов.
      - Без состояния (Stateless): Клиент и сервер не хранят информацию о состоянии друг друга между запросами. Каждый запрос должен содержать все необходимые данные для его обработки.
      - Кэширование: Серверы могут указывать клиентам, что определенные ответы могут быть кэшированы для будущих запросов. Клиенты могут использовать кэшированные данные, если они действительны.
      - Единообразный интерфейс: REST определяет ограниченный набор стандартизированных методов (например, GET, POST, PUT, DELETE), которые используются для взаимодействия с ресурсами. Интерфейс должен быть простым и понятным.
      - Слои (Layered system): Система может состоять из нескольких слоев, где каждый слой выполняет определенные функции. Клиенты не должны знать о сложности внутренней структуры системы.
      - Отсутствие состояния передачи (Uniform interface): RESTful API должно иметь единообразный интерфейс, который позволяет клиентам взаимодействовать с ресурсами по стандартизированным правилам и форматам данных, таким как JSON или XML.
15)  НТТР-методы REST.
    - GET: Используется для получения информации о ресурсе- POST: Используется для создания нового ресурса.
    - PUT: Используется для обновления существующего ресурса или создания нового ресурса с заданным идентификатором.
    - DELETE: Используется для удаления ресурса.
    - PATCH: Используется для частичного обновления ресурса.
    - HEAD: Аналогично методу GET, но возвращает только заголовки без тела ответа.
    - OPTIONS: Используется для получения информации о доступных методах на ресурсе.
16) RЕЅT контроллер. Отображения запросов. Параметры запроса и ответа.
    - REST контроллер отвечает за обработку HTTP-запросов и управление ресурсами в RESTful веб-сервисе. Он может быть реализован с использованием аннотации @RestController в Spring Framework.
    - Отображение запросов в REST контроллере осуществляется с помощью аннотаций, таких как @RequestMapping, @GetMapping, @PostMapping, и т. д. Эти аннотации позволяют определить URL-путь, на который будет отвечать метод контроллера, и указать HTTP-метод, которым должен быть обработан запрос.
    - Параметры запроса и ответа могут быть переданы через различные механизмы. Например, параметры пути (path parameters), параметры запроса (query parameters), тело запроса (request body), заголовки (headers) и другие. REST контроллер может использовать аннотации, такие как @PathVariable, @RequestParam, @RequestBody, @RequestHeader, для получения и обработки этих параметров.
17) Для чего нужен Component Scan? Как вы добавите Component Scan в Spring Boot? В чём отличие между @Component и @ComponentScan?
    - Component Scan - это механизм в Spring Framework, который автоматически сканирует и обнаруживает классы, помеченные специальными аннотациями (например, @Component, @Service, @Repository, @Controller) и регистрирует их в контейнере Spring как компоненты. Это позволяет Spring автоматически находить и создавать экземпляры этих компонентов, которые затем могут быть использованы в других частях приложения.
    - В Spring Boot Component Scan настроен автоматически для основного пакета приложения и его подпакетов. Однако, если требуется добавить дополнительные пакеты для сканирования, можно использовать аннотацию @ComponentScan в классе конфигурации приложения или в любом другом конфигурационном классе. Например:
    ```
    @SpringBootApplication
    @ComponentScan(basePackages = {"com.example.package1", "com.example.package2"})
    public class MyApplication {
        public static void main(String[] args) {
            SpringApplication.run(MyApplication.class, args);
        }
    }
    ```
    - Отличие между аннотациями @Component и @ComponentScan:
      - @Component: Это базовая аннотация, которая помечает класс как компонент Spring. Класс, помеченный @Component, становится кандидатом на автоматическое обнаружение и регистрацию в контейнере Spring. @Component является обобщенной аннотацией, которая может быть использована для различных типов компонентов.
      - @ComponentScan: Это аннотация, которая указывает Spring'у на автоматическое сканирование и обнаружение компонентов в указанных пакетах. Она не используется для непосредственной пометки класса как компонента, а служит для настройки процесса сканирования и регистрации компонентов в контейнере.
18)  Что предпочитаете использовать для конфигурации Spring
    - Класс, аннотированный @Configuration
19) Что такое Hibernate и как он связан с Java Spring
    - Hibernate - это фреймворк для объектно-реляционного отображения (ORM), который облегчает взаимодействие с базами данных из приложений Java. Он предоставляет уровень абстракции между объектной моделью приложения и базой данных, позволяя разработчикам работать с объектами и их отношениями, а не с низкоуровневыми SQL-запросами.
    - Hibernate интегрируется с Java Spring путем использования Spring Data JPA, который предоставляет удобные абстракции для работы с базами данных через Hibernate. Spring Data JPA позволяет создавать репозитории, которые автоматически генерируют реализацию CRUD-операций (создание, чтение, обновление, удаление) на основе сущностей JPA (Java Persistence API).
20) Почему для конфиденциальных данных рекомендуется использовать POST, а не GET запросы
    - GET-запросы передают параметры в URL, который может быть видимым в истории браузера, серверных логах и других местах. Это может представлять угрозу безопасности, поскольку конфиденциальные данные могут быть перехвачены или записаны в логи.
    - GET-запросы могут быть закешированы браузерами, прокси-серверами или другими промежуточными узлами, что может привести к сохранению конфиденциальных данных в кэше или журналах.
    - GET-запросы могут ограничиваться длиной URL, и передача больших объемов данных может быть проблематичной или невозможной.
    - POST-запросы передают параметры в теле запроса, которое не отображается в URL и обычно не записывается в логи сервера. Они обеспечивают большую степень конфиденциальности данных.
    - POST-запросы не подвержены ограничениям длины URL и могут передавать большие объемы данных.
