A thread affinity mask is a bit vector in which each bit represents a logical processor that a thread is allowed to run on. A thread affinity mask must be a subset of the process affinity mask for the containing process of a thread

27. Поясните понятие «мультизадачная OS с вытеснением».
    - операционная система, которая позволяет одновременно выполнять несколько задач (процессов), и в которой планировщик операционной системы может прервать выполнение текущего процесса, чтобы начать или возобновить выполнение другого.
28. Поясните понятие «циклическое планирование».
    - Каждому процессу назначается определенный интервал времени, называемый его квантом, в течение которого ему предоставляется   выполнения. Если процесс к завершению кванта времени все еще выполняется, то ресурс центрального процессора у него отбирается и передается другому процессу
29. Поясните понятие «приоритетное планирование».
    - каждому процессу присваивается значение приоритетности и запускается тот процесс, который находится в состоянии готовности и имеет наивысший приоритет
30. Поясните понятие «кооперативное планирование».
    - приложение может захватить фактически столько процессорного времени, сколько оно считает нужным. Все приложения делят процессорное время, периодически передавая управление следующей задаче
31. Поясните понятие «OS реального времени».
    - организация работы каждой задачи за определенный промежуток времени, присущий каждой конкретной задаче
32. Поясните понятие «приоритет процесса».
    - число, ориентируясь на значение которого планировщик процессов может выдавать процессу больше или меньше процессорного времени
33. Поясните выражение «поток уступает процессор другому потоку».
    - один поток прекращает выполнение, позволяя другому потоку использовать процессор
34. Windows: как поток может уступить процессор?
    - используя функции управления потоками, такие как Sleep, SwitchToThread или Yield
35. Windows: что такое базовый приоритет потока, как он вычисляется и диапазон его изменения?
    - Класс приоритета процесса и уровень приоритета потока объединяются для формирования базового приоритета каждого потока
    - Как вычисляется, хз. Вот [табличка](https://learn.microsoft.com/ru-ru/windows/win32/procthread/scheduling-priorities)
    - От 1 до 31
36. Windows: поясните назначение и принцип применения системного вызова SetThreadIdealProcessor.
    - используется для задания предпочтительного процессора для потока. Система по возможности планирует потоки на предпочитаемых процессорах
37. Windows: поясните назначение и принцип применения системного вызова ResumeThread.
    - используется для возобновления выполнения потока, который был приостановлен. Функция уменьшает счетчик приостановок потока, и когда он достигает нуля, выполнение потока возобновляется
38. Windows: поясните назначение и принцип применения системного вызова WaitForSingleObject.
    - используется для ожидания, пока указанный объект не перейдет в сигнальное состояние или пока не истечет интервал времени ожидания
39. Windows: поясните назначение и принцип применения системных вызовов GetProcessPriorityBoost, GetThreadPriorityBoost, SetProcessPriorityBoost, SetThreadPriorityBoost.
    - используются для получения состояния управления повышением приоритета указанного процесса или потока соответственно. Если функция выполняется успешно, возвращается ненулевое значение. Значение TRUE указывает, что динамическое повышение отключено, а значение FALSE указывает на нормальное поведение.
40. Linux: поясните принцип идентификации процессов и потоков и поясните почему он такой.
    - С точки зрения ядра Linux поток — особый тип процесса, который делит виртуальное адресное пространство и обработчики сигналов с другими процессами. Для ядра каждый процесс идентифицируется по PID. Для так называемых потоков можно использовать термин TID, но для ядра это одно и то же. Можно понимать это так:
      - если процесс однопоточный, то PID будет равен TID этого единственного потока;
      - если в процессе работают несколько потоков, то у каждого потока свой TID, а PID идентифицирует группу потоков
41.  Linux: Поясните понятие «планировщик потоков».  
    - Модуль ОС, отвечающий за определение порядка и распределение процессорного времени между потоками
42.  Linux: поясните принцип использования значения nice –процесса, диапазон его изменения, для какого режима работы планировщика это значение применяется?  
    - Число nice — приоритет, который пользователь хотел бы назначить процессу.
    - От -20 до 19
    - Приоритетное планирование
43.  Linux: перечислите политики планирования, какая действует по умолчанию?  
    - В Linux [есть](https://habr.com/ru/companies/ruvds/articles/578788/) три основные политики планирования: **SCHED_OTHER**, SCHED_FIFO и SCHED_RR
44.  Linux: как выяснить действующую политику планирования для процесса с помощью файловой системы proc?  
    - прочитать файл /proc/\<PID\>/sched. В этом файле поле policy указывает на текущую политику планирования
45.  Linux: с помощью какого системного вызова поток может уступить процессор.  
    - sched_yield()
46.  Linux: чем отличается системный вызов nice от вызова setpriority.  
    - setpriority позволяет установить приоритет планировщика для процесса, группы процессов и пользователя в зависимости от параметра which
47.  Linux: поясните понятие «планировщик ввода вывода», каким образом можно выяснить какие планировщики ввода/вывода доступны?  
    - Планировщик ввода/вывода в Linux определяет порядок выполнения операций ввода/вывода
    - содержимое файла /sys/block/\<device\>/queue/scheduler. 
48.  Linux: перечислите известные вам планировщики ввода/ вывода, кратко охарактеризуйте их.  
    - четыре основных планировщика ввода/вывода: noop, deadline, cfq и anticipatory. 
      - noop - это простой планировщик, основанный на алгоритме FIFO. 
      - deadline пытается гарантировать определенный максимальный срок выполнения для каждого запроса. 
      - cfq пытается обеспечить справедливое распределение ресурсов ввода/вывода между всеми процессами
      - anticipatory пытается оптимизировать производительность, предсказывая будущие запросы ввода/вывода
49.  Linux: каким образом можно выяснить тип планировщика действующего для блокового устройства?  
    - прочитать файл /sys/block/\<device\>/queue/scheduler. Текущий планировщик будет указан в квадратных скобках